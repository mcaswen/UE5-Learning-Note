UE5 中三个最核心、最常用的 Actor 生命周期函数：​**​`BeginPlay`​**​, ​**​`Tick`​**​, 和 **`​EndPlay`​​。

### 1. `BeginPlay()`

​**​`BeginPlay()`​**​ 是 Actor 或组件​**​开始参与游戏逻辑的起点​**​。

#### ​**​何时被调用？​**​

- 当一个 Actor 被​**​生成（`Spawn`）​**​ 到关卡中时。
    
- 当关卡载入，其中已存在的 `Actor` 被初始化时。
    
- 简而言之，就是在 `Actor` 的所有属性都已设置完毕、完全准备好与游戏世界交互的那一刻。

#### ​**​主要用途：​**​

- ​​初始化变量​​：设置初始生命值、分数、状态等。
    
- ​**​寻找并引用其他 `Actor`​**​：使用 `Find`或 `GetAllActorsOfClass`等函数来获取对世界中其他对象的引用。
    
- ​**​动态绑定事件​**​：绑定到委托（`Delegates`），例如响应其他 `Actor` 发生的事件（如`OnTakeDamage`）。
    
- ​**​启动定时器​**​：开始执行需要重复或延迟的任务。
    
- ​**​生成其他`Actor`​**​：在游戏开始时动态生成敌人、道具等。

### 2. `Tick()`

​**​`Tick()`​**​ 函数在​**​每一帧​**​都会被调用。它是游戏循环的心跳，用于执行需要持续更新的逻辑。
#### ​**​何时被调用？​**​

- 游戏运行的每一帧（Frame）。调用频率取决于帧率（FPS）。如果游戏运行在 60 FPS，那么它一秒内会被调用 60 次。
    
#### ​**​主要用途：​**​

- ​**​处理持续移动​**​：让物体旋转、平移或跟随路径。
    
- ​**​持续检测​**​：如射线检测（Line Trace）或检查与其他物体的距离。
    
- ​**​更新状态​**​：如逐渐减少体力值、计算冷却时间等。
    
- ​**​输入处理​**​：虽然输入通常在处理器的 `Tick`中处理，但你也可以在这里读取。
    

#### ​**​重要注意事项：​**​

- ​**​性能开销大！​**​ 不必要的 `Tick`是性能杀手。如果一个 `Actor` 不需要每帧更新，​**​务必禁用其 Tick​**​。
    
- 在 `UE5` 中，默认情况下，`Actor` 的 `Tick`是​**​启用​**​的，但频率可以通过设置控制。
    

#### ​**​如何禁用 `Tick`：​**​

- ​**​在蓝图中​**​：在 `Actor` 的“细节”面板中，找到“Actor”部分，将“允许Tick”设置为 false。
    
-  ​**​在 C++ 中​**​：
    
```
// 在类的构造函数中 
PrimaryActorTick.bCanEverTick = false; // 完全禁用 

// 或者 
PrimaryActorTick.bCanEverTick = true; 

PrimaryActorTick.bStartWithTickEnabled = false; // 创建时禁用，后续可启用
```

### 3. `EndPlay()`

​**​`EndPlay()`​**​ 是 `Actor` 或组件​**​生命周期的终点​**​。它标志着对象即将被从游戏世界中移除。

#### ​**​何时被调用？​**​

- 当 `Actor` 被明确​**​销毁（Destroy）​**​ 时。
    
- 当关卡切换或卸载时，其中的所有 `Actor` 都会触发 `EndPlay`。
    
- 当游戏结束时。
    
- 当 Actor 因为流式加载而被卸载时。

#### ​**​主要用途：​**​

- ​**​执行清理工作​**​：这是最重要的用途，防止内存泄漏和残留引用。
    
- ​**​保存状态​**​：在对象消失前记录需要保留的信息。
    
- ​**​解除事件绑定​**​：取消所有之前绑定的委托和事件。​**​这非常关键​**​，如果不解除绑定，已销毁的 Actor 可能仍然会被通知事件，导致引擎尝试调用无效内存而崩溃。
    
- ​**​停止并清除所有定时器​**​。
    

#### ​**​参数 `EndPlayReason`：​**​

该函数带有一个 `EEndPlayReason::Type`参数，说明对象为什么被移除，便于根据不同情况执行不同的清理逻辑。

- `EndPlayReason::Destroyed`：`Actor` 被手动销毁。
    
- `EndPlayReason::LevelTransition`：因关卡切换而被移除。
    
- `EndPlayReason::EndPlayInEditor`：在编辑器中停止播放。
    
- `EndPlayReason::RemovedFromWorld`：从世界中移除（常用于流式关卡）。
    
- `EndPlayReason::Quit`：游戏应用程序退出。
    

---

### 总结与最佳实践

| 函数                  | 时机                  | 核心用途                           | 注意事项                                             |
| ------------------- | ------------------- | ------------------------------ | ------------------------------------------------ |
| ​**​`BeginPlay`​**​ | ​**​初始化完成时​**​ (一次) | 设置初始状态，寻找引用，绑定事件，启动初始逻辑。       | 确保调用 `Super::BeginPlay()`。                       |
| ​**​`Tick`​**​      | ​**​每一帧​**​ (多次)    | 处理持续性的、与帧相关的逻辑（移动、检测等）。        | ​**​谨慎使用，​**​ 不需要时禁用。合理使用 `DeltaTime`保证帧率无关。     |
| ​**​`EndPlay`​**​   | ​**​销毁/移除时​**​ (一次) | ​**​关键清理！​**​ 解绑事件，清除定时器，释放资源。 | 必须调用 `Super::EndPlay()`。检查 `EndPlayReason`做不同处理。 |

​**​黄金法则：​**​

1. ​​有始有终​​：在 `BeginPlay`中创建、绑定或启动的东西，一定要在 `EndPlay`中有对应的清理操作（尤其是​​定时器​​和​​事件绑定​​）。
    
2. ​**​`Tick` 是性能之敌​**​：创建新 `Actor` 蓝图或类时，第一件事就是思考“它需要每帧更新吗？”，如果不需要，立即禁用 `Tick`。
    
3. ​**​使用 `DeltaTime`​**​：在 `Tick`中所有涉及变化（移动、旋转、数值增减）的代码都应乘以 `DeltaTime`，以确保在不同帧率的机器上表现一致。