`TArray` 是 Unreal Engine 中一个强大的、动态的、类型安全的泛型容器（模板类）。它负责管理一段连续内存，可以自动扩容和缩容，用于存储一系列相同类型的对象。它是 Unreal 序列化、垃圾回收、蓝图暴露等系统的一等公民。

---

### 核心特点

1. **​动态大小​**​： 容量可以随着元素的添加或移除而自动增长和收缩。
2. ​**​内存控制​**​： 提供对内存分配（堆、栈）和增长策略（Slack）的精细控制，有利于性能优化。
3. ​**​类型安全​**​： 模板类确保了类型安全。
4. ​**​丰富的API​**​： 提供了大量方便实用的成员函数，如 `Add`, `Remove`, `Find` 等。
5. ​**​`UE5` 集成​**​： 完美支持 `UE5` 的 `UPROPERTY` 系统（用于垃圾回收和复制）、序列化、网络复制等。
6. **​迭代器支持​**​： 支持 C++ 风格的迭代器以及更安全的范围 for 循环（C++11）。

### 常用接口分类介绍

#### 1. 添加元素

- •`Add(const ItemType& Item)` / `Add(ItemType&& Item)`： 在数组末尾添加一个元素（拷贝或移动语义）。
- •`AddUnique(const ItemType& Item)`： 添加元素，但会先检查是否已存在，避免重复。
- •`Emplace(Args&&... Args)`： ​**​（高效！）​**​ 在数组末尾直接“原地”构造一个新元素，避免创建临时对象再拷贝的开销。
    
```
TArray<FMyStruct> MyArray; MyArray.Emplace(1, "Hello"); 
// 直接调用  FMyStruct(int32, const FString&) 构造函数
```
    
- •`Insert(const ItemType& Item, int32 Index)`： 在指定索引处插入元素，后续元素后移。
- •`Append(const TArray& OtherArray)` / `Append(const CArrayType* Ptr, int32 Count)`： 将另一个数组或C数组的所有元素追加到当前数组末尾。
- •`AddZeroed(int32 Count)` / `AddUninitialized(int32 Count)`： 添加指定数量的未初始化或清零的内存空间，适用于对性能要求极高的场景。

#### 2. 移除元素

- •`Remove(const ItemType& Item)`： 移除​**​第一个​**​匹配的元素。​**​（线性查找，性能 O(n)）​**​
- •`RemoveAll(const ItemType& Item)`： 移除​**​所有​**​匹配的元素。
- •`RemoveAt(int32 Index, int32 Count = 1, bool bAllowShrinking = true)`： 移除指定索引处的一个或多个元素。
    
    - •`Count`：要移除的元素数量。
    - •`bAllowShrinking`：移除后是否允许内存缩容。
    
- •`RemoveAll([&](const auto& InItem) { return Predicate(InItem); })`： ​**​（强大！）​**​ 使用 Lambda 表达式作为谓词，移除所有满足条件的元素。
    
    `TArray<int32> Numbers = {1, 2, 3, 4, 5}; Numbers.RemoveAll([](int32 Num) { return Num % 2 == 0; }); // 移除所有偶数 -> [1, 3, 5]`
    
- •`RemoveSingle(const ItemType& Item)`： 移除单个匹配项，比 `Remove` 更明确意图。
- •`Empty(int32 Slack = 0)`： 清空数组，并可选择保留一定的预分配内存（Slack）。
- •`Reset()`： 清空数组并完全释放内存。

#### 3. 访问元素

- •`operator[](int32 Index)`： 通过索引访问元素，返回元素的引用。​**​不进行边界检查！​**​ 访问越界会导致未定义行为（通常是崩溃）。
- •`GetLast()`： 获取最后一个元素。
- •`Last()`： 获取最后一个元素的引用。
- •`GetData()`： 获取指向数组原始数据的指针（`ItemType*`）。
- •`Num()`： 获取数组中当前元素的数量。
- •`IsValidIndex(int32 Index)`： 检查索引是否有效。

#### 4. 查找元素

- •`Find(const ItemType& Item)`： 查找元素的​**​索引​**​，返回 `int32`。如果没找到，返回 `INDEX_NONE`。
- •`FindLast(const ItemType& Item)`： 从后往前查找。
- •`Contains(const ItemType& Item)`： 检查数组是否包含该元素，返回 `bool`。
- •`IndexOfByKey(KeyType Key)`： 非常强大的查找功能。可以传入一个与元素类型不同的“键”，但需要元素类型定义了 `operator==` 或自定义谓词。
    
    `TArray<FPlayerInfo> Players; int32 Index = Players.IndexOfByKey("PlayerName"); // 假设 FPlayerInfo 定义了 bool operator==(const FString&) const`
    

#### 5. 迭代

- •​**​范围 for 循环 (推荐)​**​：
    
    `for (const auto& Item : MyArray) {     // 处理 Item }`
    
- •​**​索引 for 循环​**​：
    
    `for (int32 i = 0; i < MyArray.Num(); ++i) {     // 处理 MyArray[i] }`
    
- •​**​创建迭代器​**​ (较少使用)：
    
    `for (auto It = MyArray.CreateIterator(); It; ++It) {     // 处理 *It }`
    

#### 6. 内存管理 (性能关键)

- •`Reserve(int32 Number)`： 预先分配足够的内存来容纳指定数量的元素，避免多次扩容。​**​重要的性能优化手段。​**​
- •`SetNum(int32 NewNum, bool bAllowShrinking = true)`： 直接设置数组的元素数量。可以扩容（新元素默认初始化）或缩容。
- •`Shrink()`： 释放未使用的预分配内存，减小内存占用。
- •`GetSlack()`： 获取当前预分配但未使用的元素数量。

---

### 重要注意事项

1. ​**​索引越界 (Index Out of Bounds)​**​：
    
    - •`operator[]` ​**​不进行边界检查​**​，速度最快，但最危险。
    - •如果需要安全访问，使用 `IsValidIndex` 先检查，或者使用 `TArray::IsValidIndex`。
    - •`UE5` 在 `Development` 和 `Debug` 构建下，某些函数内部会有断言(`check`)来检查越界，但发布版本中没有。
    
2. ​**​迭代器失效 (Iterator Invalidation)​**​：
    
    - •在迭代过程中（使用范围 for 循环或迭代器），​**​绝对不能​**​添加或移除元素（除非是当前正在处理的元素），这会改变数组内存布局，导致迭代器失效和崩溃。
    - •如果需要修改，可以先记录要修改的索引或元素，在迭代结束后再统一处理，或者使用 `RemoveAll` 这种自带谓词的函数。
    
3. ​**​元素类型​**​：
    
    - •`TArray` 可以存储 ​**​`UObject`​**​（派生自 `UObject` 的类）。存储的是对象指针（`TArray<UMyObject*>`），由 Unreal 的垃圾回收器管理。
    - •存储 ​**​`UStruct`​**​（如 `FVector`, `FMyStruct`）时，是值语义，数组拥有这些结构体的拷贝。
    - •存储裸指针或第三方库对象时，需要自行管理其生命周期。
    
4. ​**​`UPROPERTY()` 宏​**​：
    
    - •如果 `TArray` 是 `UCLASS` 的成员变量，并且需要被垃圾回收、复制、序列化或在蓝图中使用，​**​必须​**​用 `UPROPERTY()` 标记。
    
    `UPROPERTY(EditAnywhere, BlueprintReadWrite) TArray<AActor*> TargetActors; // UObject 指针数组  UPROPERTY() TArray<FVector> Locations; // 结构体数组`
    
5. ​**​移动语义 (Move Semantics)​**​：
    
    - •优先使用 `Emplace` 和 `Add` 的移动重载版本（`Add(MoveTemp(MyObject))`）来避免不必要的拷贝，提升性能。
    
6. ​**​算法函数​**​：
    
    - •`TArray` 自带了很多实用算法，如 `Sort()`，`HeapSort()`，`StableSort()`，以及 `FilterByPredicate` 等，通常比手动实现循环更高效和安全。