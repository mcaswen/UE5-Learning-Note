是 `UE5` 中用于存储​**​唯一元素​**​的高效容器，基于哈希表实现，其核心任务是提供快速的元素存在性检查、添加和删除。
### 什么是 TSet？

`TSet<ElementType>`是一个存储​**​唯一对象​**​的集合。你可以将其理解为一个只存储“键”而没有对应“值”的 `TMap`。它的设计目标是：

- ​**​唯一性 (Uniqueness)：​**​ 集合中的每个元素都是唯一的。
    
- ​**​快速查找：​**​ 判断一个元素是否在集合中的速度极快（平均时间复杂度 O(1)）。
    
- ​**​无序性：​**​ 元素没有固定的顺序。
    
它类似于 C++ 标准库中的 `std::unordered_set`。
### 核心特点与设计哲学

1. ​​基于哈希表：​​ 和 `TMap`一样，使用哈希函数来定位元素，这是其高性能的基石。
    
2. ​**​“键”即“值”：​**​ 元素本身 (`ElementType`) 就是其键，因此元素类型也必须满足哈希和判等要求。
    
3. ​**​极度优化于存在性查询：​**​ `Contains()`操作是其最快、最核心的功能。
    
4. ​**​无重复添加：​**​ 添加一个已存在的元素不会有任何效果。
    
5. ​**​没有“位置”概念：​**​ 你不能像 `TArray`那样通过索引来访问元素，因为它本质上是无序的。
    
​**​与 `TArray`/`TMap` 的简单对比：​**​
- ​**​`TArray`​**​: 当需要​**​顺序​**​、​**​重复​**​的元素，并且经常通过​**​索引​**​访问时使用。
    
- ​**​`TMap`​**​: 当需要通过一个​**​键 (Key)​**​ 来关联并查找一个​**​值 (Value)​**​ 时使用。
    
- ​**​`TSet`​**​: 当你只关心一个元素​**​是否存在​**​，或者你需要维护一个​**​唯一​**​的元素列表时使用。
### 常用接口分类介绍

#### 1. 添加元素

- `Add(const ElementType& Item)`/ `Add(ElementType&& Item)`： 向集合中添加一个元素。如果元素已存在，则​**​什么都不做​**​（集合保持不变）。
    
- `Emplace(Args&&... Args)`： ​**​（高效！）​**​ 在集合中直接“原地”构造一个新元素，避免创建临时对象再拷贝的开销。
```
TSet<FString> Names; Names.Emplace(TEXT("Alice")); // 直接在集合内部构造一个FString("Alice")
```
    
- `Append(const TSet& OtherSet)`： 将另一个集合中的所有元素追加到当前集合中（已存在的元素会自动去重）。
    

#### 2. 查找元素

- `Contains(const ElementType& Item)`： ​**​（核心功能！）​**​ 检查集合中是否包含指定元素，返回 `bool`。这是 `TSet`最快、最常用的操作。
```
if (Names.Contains(TEXT("Bob"))) 
{     
	// 做点什么... 
}
```
    
- `Find(const ElementType& Item)`： 返回一个指向集合中元素的​**​指针​**​。如果找到，可以通过指针修改该元素（前提是修改不会影响其哈希值）；如果没找到，返回 `nullptr`。
    
```
if (FString* Ptr = Names.Find(TEXT("Alice"))) 
{
     *Ptr = TEXT("Alice Smith"); // 修改集合内的元素     
     // 注意：不能修改到影响哈希值的成员！否则会破坏集合结构。 
}
```
    
#### 3. 移除元素

- `Remove(const ElementType& Item)`： 移除指定的元素。返回移除的元素数量（0或1）。
    
- `FindAndRemoveChecked(const ElementType& Item)`： 找到并移除元素，如果元素不存在则触发断言（`check`）。
    
- `RemoveAll([&](const auto& Item) { return Predicate(Item); })`： 使用 Lambda 表达式作为谓词，移除所有满足条件的元素。
```
Names.RemoveAll([](const FString& Name) 
{ 
return Name.StartsWith(TEXT("A")); 
}); // 移除所有以"A"开头的名字`
```
    
- `Empty(int32 Slack = 0)`： 清空集合，并可选择保留一定的预分配内存（Slack）。
    

#### 4. 遍历元素

- ​**​范围 for 循环 (推荐)​**​：
```
for (const FString& Name : Names) 
{     
    UE_LOG(LogTemp, Log, TEXT("Name: %s"), *Name); 
}
```
    
- ​**​创建迭代器​**​：
```
for (auto It = Names.CreateIterator(); It; ++It) 
{     
	const FString& Name = *It;     
	// It.Remove() 可以在迭代中移除当前元素 
}
```

#### 5. 集合操作 (非常有用的工具函数)

`TSet`提供了一系列标准的数学集合操作。

- `Union(const TSet& OtherSet)`： ​**​并集​**​。将当前集合与另一个集合合并，当前集合将包含所有存在于​**​任一​**​集合中的元素。
    
- `Intersect(const TSet& OtherSet)`： ​**​交集​**​。当前集合只保留那些在​**​两个​**​集合中都存在的元素。
    
- `Difference(const TSet& OtherSet)`： ​**​差集​**​。从当前集合中移除所有也存在于另一个集合中的元素。
```
TSet<int32> SetA = {1, 2, 3};
TSet<int32> SetB = {3, 4, 5};  
SetA.Union(SetB);      // SetA 变为 {1, 2, 3, 4, 5} 
// SetA.Intersect(SetB); // SetA 变为 {3} 
// SetA.Difference(SetB); // SetA 变为 {1, 2}
```
    

#### 6. 工具函数

- `Num()`： 获取集合中元素的数量。
    
- `Reserve(int32 Number)`： 预先分配足够的内存来容纳指定数量的元素，避免多次扩容，提升性能。
    
- `GetAllocatedSize()`： 获取集合当前分配的内存大小。

### 重要注意事项

1. ​**​元素的类型要求 (与 TMap 的 Key 相同)​**​：
    
    - 存储在 `TSet`中的类型 `ElementType`​**​必须​**​具有：
        - ​**​`GetTypeHash(const ElementType&)`​**​： 一个返回 `uint32`的全局哈希函数。
            
        - ​**​`operator==`​**​： 用于比较元素是否相等。
            
        
    - Unreal 已为常用类型提供了实现。​**​为自定义类型创建元素​**​时，必须重写这两个函数。
        
```
struct FMyStruct {
    int32 X;
    int32 Y;      
    // 哈希函数     
    friend uint32 GetTypeHash(const FMyStruct& MyStruct)     
    {         
	    return HashCombine(GetTypeHash(MyStruct.X), GetTypeHash(MyStruct.Y));     }     
	// 相等运算符     
	bool operator==(const FMyStruct& Other) const     
	{         
		return X == Other.X && Y == Other.Y;     
	} 
};
```
        
    
2. ​**​通过 `Find()`指针修改元素的危险性​**​：
    
    - 你可以通过 `Find()`返回的指针修改元素，但​**​绝对不允许​**​修改任何参与计算哈希值(`GetTypeHash`)或相等性比较(`operator==`)的成员。
        
    - 例如，如果你修改了 `FMyStruct`中的 `X`，其哈希值会改变，但它在集合中的存储位置（由旧的哈希值决定）不会变。这会导致集合内部状态损坏，后续的查找、删除等操作将出现不可预料的错误。
        
    - ​**​安全实践​**​： 如果确实需要修改一个元素，正确的做法是：先 `Remove`旧元素，修改后再 `Add`新元素。
        
    
3. ​**​迭代器失效​**​：
    
    - 在遍历 `TSet`时，​**​添加或删除元素​**​（除了通过迭代器的 `Remove()`方法）可能会导致内部哈希表重组，从而使迭代器失效。
        
    - 如果需要修改，应先记录要处理的元素，遍历结束后再操作，或使用 `RemoveAll`
        
    
4. **​`​UPROPERTY()` 宏​**​：
    
    - 如果 `TSet`是 `UCLASS`的成员变量，并且需要被垃圾回收、复制、序列化或在蓝图中使用，​**​必须​**​用 `UPROPERTY()`标记。
        
    - `TSet`可以被标记为 `UPROPERTY()`，但其​**​元素类型​**​必须是 `UE5` 支持的类型。
        
    
```
UPROPERTY(EditAnywhere, BlueprintReadWrite) 
TSet<AActor*> ImportantActors; // 例如：一个需要被跟踪的重要Actor集合
```
    
5. ​**​性能考量​**​：
    
    - ​**​哈希冲突​**​： 糟糕的哈希函数会导致性能下降。
        
    - ​**​预留内存​**​： 使用 `Reserve()`可以显著提升性能，特别是在你知道要插入大量元素时。
        
    

### 总结

`TSet`是 `UE5` `C++` 中处理​**​唯一性​**​和​**​快速存在性检查​**​问题的利器。

- ​**​当你需要回答“这个东西有吗？”时，用 `TSet`。​**​
    
- 它的核心接口是 `Add`, `Contains`, 和 `Remove`。
    
- 牢记​**​元素的类型要求​**​，必须提供正确的哈希和判等函数。
    
- ​**​严禁​**​通过 `Find()`得到的指针修改影响哈希值的成员。
    
- 善用​**​集合操作​**​（并集、交集、差集）可以简化很多逻辑。
    
- 正确使用 `UPROPERTY()`以实现与 `UE5` 引擎功能的集成。